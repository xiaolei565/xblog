从一个表的更新语句说起，这个表有一个主键ID和一个整型字段c；

`mysql> create table T(ID int primary key, c int);`

如果要将ID=2这一行的值加1，SQL语句就会这么写：

`mysql> update T set c=c+1 where ID=2;`

执行步骤和之前查询语句一样

- 执行语句之前，需要连接数据库，这是连接器的工作
- 查询缓存在更新后全部失效
- 分析器通过词法和语法分析，这是一条更新语句，且没有问题
- 优化器决定要使用ID这个索引
- 执行器负责具体执行，找到这一行，然后更新



与查询流程不一样的是：更新流程涉及两个重要的日志模块：**redo log（重做日志）**和**binlog（归档日志）**
### redo log
这里借助《孔乙己》中赊账的案例说明，如果赊账的人不多，老板可以将账目记在黑板上，但如果赊账人太多，黑板记不下，这时候老板还有个专门记录赊账的账本可以记录。如果有人要赊账或者还账的话，老板有两种做法

1. 直接将账本翻出来，将这次赊账加上，或者还账扣除
1. 先在黑板上记下这次的账目，然后等晚上在拿账本进行核算



其实MySQL中也有类似的问题，**如果每一次更新操作都写入磁盘，然后磁盘也要找到对应的那条记录，然后再更新，这个IO和查找成本都很高**。为了解决这个问题，MySQL也有类似账本和黑板配合的设计，常说的WAL（Write-Ahead Logging）它的关键点就是**先写日志，再写磁盘**，类比记账中的方法2.


具体来说，就是当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这时候更新就已经完成了，同时InnoDB引擎会在适当的时候将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候

此时有个问题，如果更新太多，redo log 记录不下怎么办，那么这时候就需要将像老板一样，将黑板上一些擦除并记录到账本中。redo log是固定大小的，比如可以配置为一组四个文件，每个文件大小1GB，那么这个“黑板”就可以记录4GB的操作，从头开始写，写到末尾又从头开始循环写

![image.png](img/1624538179617-35d31495-97fe-4a57-be5a-6ef510e9c2a3.png)

图中write pos是记录当前记录的位置，一边写，一边往后移动，当写到ib_logfile_3的文件末尾时，就循环到0号文件开头，继续写，checkpoint时当前要擦除的部分，这个也是循环后移的，擦除记录前就要把记录更新到数据文件中。
在checkpoint-->write pos之间的位置，就是“黑板中记录的数据”，write pos--> checkpoint之间的位置就是“黑板中空余位置”，如果wp追上cp，表示黑板已经满了，这时候，必须进行擦除，将记录写到硬盘里面


_**有了redo log,InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe**_


### binlog
前面redo log是InnoDB引擎专有的日志，属于引擎层，而binlog属于Server层，所有引擎都有这个


##### 为什么会有两个日志
因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。


##### 两个日志有什么不同

1. **redo log是InnoDB引擎特有的，而binlog是Server层，所有引擎都可以使用**
1. **redo log是物理日志，记录的是“在某个数据页上做了什么修改”，binlog是逻辑日志，记录的是这个日志的原始逻辑。比如：“给ID=2这一行的c字段上+1”**
1. **redo log是循环写的，空间固定会用完，binlog是可以追加写入的，“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前日志**





#### 再来看更新流程
有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。

![](img/1616147375691-82a0ed83-605f-470d-b17b-4d19e67550b0.png)

1. 执行器先找引擎取ID=2的这一行，ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回
1. 执行器拿到引擎给的行数据，把这个值加上1，得到新的一行数据，再调用引擎接口写入这行新数据
1. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务
1. 执行器生成这个操作的binlog，并把binlog写入磁盘
1. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成

注意：redo log的写入拆分成了两个步骤：prepare和commit，这就是**两阶段提交**
**为什么需要两段提交？？？**
**​**

#### 两阶段提交
如何让数据库恢复到半个月内任意一秒的状态？？？


从前面知道了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。
如果需要恢复半个月内任意时刻的状态，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。


当需要恢复到指定的时刻时：

1. 先找到最近一次的全量备份，如昨天晚上的，将这个备份恢复到临时库
1. 然后从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻
1. 这样临时库就和误删之前的线上库一样了，可以将临时库中表数据取出来，按需要恢复到线上库中



反过来探讨刚刚的问题，为什么需要两段提交？？？


这里使用反证法来解释：
由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog 或者采用反过来的顺序。这里还采用之前update的例子，假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完用第一个日志后，第二个日志还没写完期间发生了crash，这样会出什么问题呢？？？

1. 先写redo log 再写binlog：假设再redo log写完，binlog还没写完的时候，MySQL进程异常重启。
   - 前面说过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，恢复完这一行c的值是1
   - 但是由于binlog没有写就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句
   - 然后如果需要用这个binlog来**恢复临时库**的话，由于这个语句的binlog丢失，这个临时库就会丢失这一次的更新，恢复出来这一行c的值就是0，与原库不同（备份库和线上库不一致）
> 这样会出现 redo log 写入到磁盘了，但是 binlog 还没写入磁盘，于是当发生 crash recovery 时，恢复后，主库会应用 redo log，恢复数据，但是由于没有 binlog，从库就不会同步这些数据，主库比从库“新”，造成主从不一致

2. 先写binlog后写redo log：如果在binlog写完之后crash。
   - 由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0
   - 但是binlog里面已经记录了 “把c从0改到1”这个日志
   - 在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同（备库一般用binlog恢复）
> 跟上一种情况类似，很容易知道，这样会反过来，造成从库比主库“新”，也会造成主从不一致
> [https://www.jianshu.com/p/125fbcb11206](https://www.jianshu.com/p/125fbcb11206)

可以看到，如果不是两阶段提交，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一样。




你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？
其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。
简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

